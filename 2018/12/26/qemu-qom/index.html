<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.8.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.owalle.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="什么是QOMQOM(Qemu Object Model)是QEMU最新的设备模型，将所有的模拟设备整合成了一种单根结点(系统总线)的树状形式，并具有热插拔功能。后来可能由于Device和Bus之间的复杂关系，又开发了QOM。QOM是QEMU在C的基础上自己实现的一套面向对象机制，负责将device、bus等设备都抽象成为对象。">
<meta name="keywords" content="QEMU,QOM">
<meta property="og:type" content="article">
<meta property="og:title" content="利用QOM(Qemu Object Model)创建虚拟设备">
<meta property="og:url" content="http://www.owalle.com/2018/12/26/qemu-qom/index.html">
<meta property="og:site_name" content="Yi颗烂樱桃">
<meta property="og:description" content="什么是QOMQOM(Qemu Object Model)是QEMU最新的设备模型，将所有的模拟设备整合成了一种单根结点(系统总线)的树状形式，并具有热插拔功能。后来可能由于Device和Bus之间的复杂关系，又开发了QOM。QOM是QEMU在C的基础上自己实现的一套面向对象机制，负责将device、bus等设备都抽象成为对象。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2021-09-27T09:54:43.266Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="利用QOM(Qemu Object Model)创建虚拟设备">
<meta name="twitter:description" content="什么是QOMQOM(Qemu Object Model)是QEMU最新的设备模型，将所有的模拟设备整合成了一种单根结点(系统总线)的树状形式，并具有热插拔功能。后来可能由于Device和Bus之间的复杂关系，又开发了QOM。QOM是QEMU在C的基础上自己实现的一套面向对象机制，负责将device、bus等设备都抽象成为对象。">

<link rel="canonical" href="http://www.owalle.com/2018/12/26/qemu-qom/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>利用QOM(Qemu Object Model)创建虚拟设备 | Yi颗烂樱桃</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Yi颗烂樱桃</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">虚拟化中文</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-fw fa-sitemap"></i>Sitemap</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" placeholder="Searching..." spellcheck="false" type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope="" itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://www.owalle.com/2018/12/26/qemu-qom/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yi颗烂樱桃">
      <meta itemprop="description" content="这是一颗烂樱桃的技术博客，一个微不足道的魔都程序员，或者是自以为的程序员">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yi颗烂樱桃">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          利用QOM(Qemu Object Model)创建虚拟设备
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-12-26 09:42:27" itemprop="dateCreated datePublished" datetime="2018-12-26T09:42:27+08:00">2018-12-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-09-27 17:54:43" itemprop="dateModified" datetime="2021-09-27T17:54:43+08:00">2021-09-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/QEMU/" itemprop="url" rel="index"><span itemprop="name">QEMU</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="什么是QOM"><a href="#什么是QOM" class="headerlink" title="什么是QOM"></a>什么是QOM</h2><p>QOM(Qemu Object Model)是QEMU最新的设备模型，将所有的模拟设备整合成了一种单根结点(系统总线)的树状形式，并具有热插拔功能。后来可能由于Device和Bus之间的复杂关系，又开发了QOM。<br>QOM是QEMU在C的基础上自己实现的一套面向对象机制，负责将device、bus等设备都抽象成为对象。</p>
<h2 id="QOM-的初始化"><a href="#QOM-的初始化" class="headerlink" title="QOM 的初始化"></a>QOM 的初始化</h2><p>对象的初始化分为四步：</p>
<ul>
<li>将 TypeInfo 注册 TypeImpl</li>
<li>实例化 ObjectClass</li>
<li>实例化 Object</li>
<li>添加 Property</li>
</ul>
<p>根据QEMU的wiki ，QOM没有构造和析构的概念。但矛盾的是根据代码，TypeInfo 中定义的 class_init 和 instance_init 无论从名字还是实现上都做了对象的初始化工作，比如设置对象成员的值。但为什么说它们最多只能算是初始化函数呢？<br><code>Everything in QOM is a device</code><br>根据实现，经过 class_init 和 instance_init 产生设备对应Object后，这个Object是不能直接使用的。其真正初始化逻辑的大头都放在 realize 中做，比如创建对应的memory region，挂载到对应bus上等等。只有在 realize 后，设备才算真正构造完成，可以拿来用了。因此QEMU认为，类似构造和析构的是realize和unrealize。而在设备的生命周期中，可以被realize和unrealize多次。<br>为了保持习惯，本文会依然将 class_init 和 instance_init 当做构造函数，称前者为类构造函数，后者为类实例构造函数。</p>
<h2 id="使用QOM添加设备源码分析"><a href="#使用QOM添加设备源码分析" class="headerlink" title="使用QOM添加设备源码分析"></a>使用QOM添加设备源码分析</h2><p>下面我们就利用一个真实的案例，讲解一下利用QOM添加设备的具体实现步骤</p>
<h3 id="TypeInfo-gt-ModuleEntry"><a href="#TypeInfo-gt-ModuleEntry" class="headerlink" title="TypeInfo =&gt; ModuleEntry"></a>TypeInfo =&gt; ModuleEntry</h3><p>设备相关代码的入口就是这里了, TypeInfo 定义了一种类型，并且使用函数type_register_static注册：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static const TypeInfo caffee_agent_info = &#123;</span><br><span class="line">    .name          = &quot;caffee-agent&quot;,</span><br><span class="line">    .parent        = TYPE_ISA_DEVICE,</span><br><span class="line">    .class_init    = caffee_agent_class_init,</span><br><span class="line">    .instance_size = sizeof(CaffeeAgentState),</span><br><span class="line">    .instance_init = caffee_agent_initfn,</span><br><span class="line">&#125;;</span><br><span class="line">                                             </span><br><span class="line">static void caffee_agent_register_types (void)</span><br><span class="line">&#123;</span><br><span class="line">    type_register_static (&amp;caffee_agent_info);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type_init(cafe_agent_register_types)</span><br></pre></td></tr></table></figure>
<p>包含 类型的名称(name)、父类名称(parent)、Object实例的大小(instance_size)、是否抽象类(abstract)、初始化函数(class_init)。<br>代码底部有 type_init ，由 C run-time(CRT)负责执行：<br><!--
`type_init(kvm_type_init) => module_init(function, MODULE_INIT_QOM) => register_module_init(function, type)`
--></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">op1=&gt;operation: type_init(kvm_type_init)</span><br><span class="line">op2=&gt;operation: module_init(function, MODULE_INIT_QOM)</span><br><span class="line">op3=&gt;operation: register_module_init(function, type)</span><br><span class="line">op1(right)-&gt;op2(right)-&gt;op3</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void register_module_init(void (*fn)(void), module_init_type type)</span><br><span class="line">&#123;</span><br><span class="line">    ModuleEntry *e;</span><br><span class="line">    ModuleTypeList *l;</span><br><span class="line"></span><br><span class="line">    e = g_malloc0(sizeof(*e));</span><br><span class="line">    e-&gt;init = fn;</span><br><span class="line">    e-&gt;type = type;</span><br><span class="line"></span><br><span class="line">    l = find_type(type);</span><br><span class="line"></span><br><span class="line">    QTAILQ_INSERT_TAIL(l, e, node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建了 type 为 MODULE_INIT_QOM ，init为 kvm_type_init 的 ModuleEntry ，并加入到 MODULE_INIT_QOM 的 ModuleTypeList 中。</p>
<h3 id="ModuleEntry-gt-TypeImpl"><a href="#ModuleEntry-gt-TypeImpl" class="headerlink" title="ModuleEntry =&gt; TypeImpl"></a>ModuleEntry =&gt; TypeImpl</h3><p>在 main.c(vl.c) 的一开始执行了 module_call_init(MODULE_INIT_QOM) ，它从 init_type_list 中取出对应的 ModuleTypeList ，然后对里面的 ModuleEntry 成员都调用 init 函数。<br>对于上文提到的 ModuleEntry ，调用的是：<br><!---
`kvm_type_init => type_register_static(&kvm_accel_type) => type_register => type_register_internal`
--></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">op1=&gt;operation: kvm_type_init</span><br><span class="line">op2=&gt;operation: type_register_static(&amp;kvm_accel_type)</span><br><span class="line">op3=&gt;operation: type_register</span><br><span class="line">op4=&gt;operation: type_register_internal</span><br><span class="line"></span><br><span class="line">op1(right)-&gt;op2(right)-&gt;op3(right)-&gt;op4</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static TypeImpl *type_register_internal(const TypeInfo *info)</span><br><span class="line">&#123;</span><br><span class="line">    TypeImpl *ti;</span><br><span class="line">    ti = type_new(info);</span><br><span class="line"></span><br><span class="line">    type_table_add(ti);</span><br><span class="line">    return ti;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它根据 kvm_accel_type(TypeInfo) 创建一个名为TYPE_KVM_ACCEL的 TypeImpl 类型的结构。<br>同时将该 TypeImpl 注册到全局 type_table 中，key为类型名称，即 TYPE_KVM_ACCEL</p>
<h3 id="ObjectClass"><a href="#ObjectClass" class="headerlink" title="ObjectClass"></a>ObjectClass</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct ObjectClass</span><br><span class="line">&#123;</span><br><span class="line">    /*&lt; private &gt;*/</span><br><span class="line">    Type type;              // 用typedef定义的 TypeImpl 指针</span><br><span class="line">    GSList *interfaces;</span><br><span class="line"></span><br><span class="line">    const char *object_cast_cache[OBJECT_CLASS_CAST_CACHE];</span><br><span class="line">    const char *class_cast_cache[OBJECT_CLASS_CAST_CACHE];</span><br><span class="line"></span><br><span class="line">    ObjectUnparent *unparent;</span><br><span class="line"></span><br><span class="line">    GHashTable *properties;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>ObjectClass 属于类对象，它是所有类对象的基类。</p>
<h4 id="TypeImpl-gt-ObjectClass"><a href="#TypeImpl-gt-ObjectClass" class="headerlink" title="TypeImpl =&gt; ObjectClass"></a>TypeImpl =&gt; ObjectClass</h4><p>有两种路径，一种是主动地调用：<br><!---
`object_class_get_list => object_class_foreach => g_hash_table_foreach(object_class_foreach_tramp) => object_class_foreach_tramp => type_initialize`
--><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">op1=&gt;operation: object_class_get_list</span><br><span class="line">op2=&gt;operation: object_class_foreach</span><br><span class="line">op3=&gt;operation: g_hash_table_foreach(object_class_foreach_tramp)</span><br><span class="line">op4=&gt;operation: object_class_foreach_tramp</span><br><span class="line">op5=&gt;operation: type_initialize</span><br><span class="line"></span><br><span class="line">op1(right)-&gt;op2(right)-&gt;op3(right)-&gt;op4(right)-&gt;op5</span><br></pre></td></tr></table></figure></p>
<p>比如 object_class_get_list(TYPE_DEVICE, false) 创建 TYPE_DEVICE 类型的 ObjectClass<br>该过程用到glic的函数 g_hash_table_foreach ，见 <a href="https://developer.gnome.org/glib/stable/glib-Hash-Tables.html#g-hash-table-foreach" target="_blank" rel="noopener">https://developer.gnome.org/glib/stable/glib-Hash-Tables.html#g-hash-table-foreach</a><br>另一种是被动调用，如:</p>
<ul>
<li>object_class_by_name</li>
<li>object_class_get_parent</li>
<li>object_new_with_type</li>
<li>object_initialize_with_type</li>
</ul>
<p>在获取 class、class的parent、创建type的object、初始化TypeImpl的object时，调用 type_initialize<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">type_initialize</span><br><span class="line">=&gt; 如果 TypeImpl 已创建(class成员有值)，返回</span><br><span class="line">=&gt; ti-&gt;class = g_malloc0(ti-&gt;class_size)                    根据class_size分配内存空间</span><br><span class="line">=&gt; type_get_parent(ti)                                      获取父类的TypeImpl</span><br><span class="line">=&gt; memcpy(ti-&gt;class, parent-&gt;class, parent-&gt;class_size)     将parent的class拷贝到自己class的最前面</span><br><span class="line">=&gt; ti-&gt;class-&gt;properties = g_hash_table_new_full            创建存放property的hash table</span><br><span class="line">=&gt; type_initialize_interface                                初始化class的接口，包括父类和自己的</span><br><span class="line">=&gt; ti-&gt;class-&gt;type = ti                                     设置class的type为对应TypeImpl</span><br><span class="line">=&gt; parent-&gt;class_base_init                                  如果parent定义了 class_base_init ，调用之</span><br><span class="line">=&gt; ti-&gt;class_init(ti-&gt;class, ti-&gt;class_data)                调用class的 class_init</span><br></pre></td></tr></table></figure></p>
<p>对于 kvm_accel_type 这个 TypeInfo 的 TypeImpl ，调用的class_init是 kvm_accel_class_init ，它将传入的 ObjectClass 强转为子类 AccelClass ，设置 init_machine 成员为 kvm_init<br>这里的class是该类型的类实例，它的基类是 ObjectClass 。</p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>从创建流程可以看出，在创建类对象时，会调用 type_initialize ，其会递归地对 TypeImpl 中的 parent 成员(TypeImpl)递归调用 type_initialize ，然后将创建出来的相应 ObjectClass 拷贝到自己class的最前面。<br>类对象的第一个成员是 parent_class ，由于父类对象会拷到子类对象的最前面，因此可以认为其指向父类的对象，如此构成链状的继承链，最终指向基类对象 ObjectClass<br>比如 kvm_accel_type 对应的类对象，该类对象作为叶子类型并没有定义，但其父类 AccelClass 在代码中有定义，其的第一个成员为 ObjectClass ，表示其继承自 ObjectClass 。为了能表示该叶子类型继承 AccelClass ，它修改了 AccelClass的一些对象成员，这样在某种程度上表示了继承关系。比如修改了函数指针成员的指向，相当于实现了虚函数。<br>又如： <code>register_info 对应的类对象 =&gt; PCIDeviceClass =&gt; DeviceClass =&gt; ObjectClass</code> 构成继承链，最前端的叶子类型通过修改 PCIDeviceClass 成员进行定义。</p>
<h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><p>将一个父类的指针转换为子类的指针是不安全的，为了实现这种转换，各类需要提供强制类型转换的宏，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define ACCEL_CLASS(klass) \</span><br><span class="line">    OBJECT_CLASS_CHECK(AccelClass, (klass), TYPE_ACCEL)</span><br><span class="line"></span><br><span class="line">#define OBJECT_CLASS_CHECK(class_type, class, name) \</span><br><span class="line">    ((class_type *)object_class_dynamic_cast_assert(OBJECT_CLASS(class), (name), \</span><br><span class="line">                                               __FILE__, __LINE__, __func__))</span><br></pre></td></tr></table></figure></p>
<p>如果类对象指针的name和目标子类的name一致，或类对象指针是目标子类的祖先，则执行转换，否则 abort<br>反过来，从子类指针转换为父类指针是安全的，因为类的第一项就指向父类，访问时不会存在越界等问题。 </p>
<h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p>Object 属于类实例对象，它是所有类实例对象的基类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct Object</span><br><span class="line">&#123;</span><br><span class="line">    /*&lt; private &gt;*/</span><br><span class="line">    ObjectClass *class;             // 指向类对象</span><br><span class="line">    ObjectFree *free;</span><br><span class="line">    GHashTable *properties;         // 维护属性的哈希表</span><br><span class="line">    uint32_t ref;                   // 引用计数</span><br><span class="line">    Object *parent;                 // 指向父类实例对象，实现继承</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>可以看到其第一个成员指向类对象，同时维护有区别于类属性的类实例属性。</p>
<h4 id="创建流程"><a href="#创建流程" class="headerlink" title="创建流程"></a>创建流程</h4><p>就流程而言，在C runtime 根据 TypeInfo 创建了 TypeImpl 后，此后主要根据 TypeImpl 创建 ObjectClass 和 Object<br>以 TypeInfo(kvm_accel_type) 为例，其创建的 TypeImpl 在以下流程发挥作用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">main =&gt; configure_accelerator =&gt; accel_init_machine(acc, ms)</span><br><span class="line">=&gt; ObjectClass *oc = OBJECT_CLASS(acc)                                  将AccelClass指针转换成父类(ObjectClass)指针</span><br><span class="line">=&gt; object_class_get_name                                                获取 ObjectClass-&gt;TypeImpl 的类名，如 kvm-accel</span><br><span class="line">=&gt; ACCEL(object_new(cname))                                             利用名称创建 AccelState 对象</span><br><span class="line">=&gt; acc-&gt;init_machine(ms)                                                初始化machine，实际上是调用 kvm_init</span><br><span class="line"></span><br><span class="line">object_new</span><br><span class="line">=&gt; type_get_by_name(typename)                                           根据类名查type_table获取 TypeImpl</span><br><span class="line">=&gt; object_new_with_type =&gt; type_initialize                              创建 TypeImpl 对应的类对象，设置到对应 TypeImpl-&gt;class 中</span><br><span class="line">                        =&gt; g_malloc(type-&gt;instance_size)                分配类实例对象的内存</span><br><span class="line">                        =&gt; object_initialize_with_type                  创建类实例对象</span><br><span class="line">                            =&gt; type_initialize  会再次尝试实例化类对象</span><br><span class="line">                            =&gt; obj-&gt;class = type-&gt;class                 设置类实例对象的类对象为 TypeImpl-&gt;class</span><br><span class="line">                            =&gt; obj-&gt;properties = g_hash_table_new_full  创建存放类实例对象property的hash table</span><br><span class="line">                            =&gt; object_init_with_type =&gt; object_init_with_type   如果 TypeImpl 有父类，递归调用object_init_with_type</span><br><span class="line">                                                     =&gt; ti-&gt;instance_init(obj)  如果定义了类实例的构造函数，调用之</span><br></pre></td></tr></table></figure></p>
<h4 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h4><p>定义上的继承主要指类的继承，既然类对象已经通过包含的方式实现了继承，那么类实例对象就可以通过调用自己的class成员调用父类的函数，访问父类的class property。<br>但在QEMU实现的这套面向对象模型中，类实例对象也拥有自己的构造函数，因此根据继承关系，需要对父类实例对象的构造函数进行调用。<br>从创建流程可以看出，在创建类实例对象时，会调用 object_init_with_type ，其会递归地对 TypeImpl 中的 parent 成员递归调用 object_init_with_type ，从而让所有父类的 instance_init 都得到调用，在调用时传入的是当前对象的地址，相当于在当前对象上对父类实例对象进行构造。<br>同理，类实例对象的第一个成员是 parent_obj ，指向父类的实例对象，如此构成链状的继承链，最终指向基类实例对象 Object<br>如： kvm_accel_type的类实例Object =&gt; AccelState =&gt; Object<br>又如： register_info的类实例Object =&gt; PCIDevice =&gt; DeviceState =&gt; Object</p>
<h4 id="强制类型转换-1"><a href="#强制类型转换-1" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><p>同理，将一个父类实例的指针转换为子类实例指针是不安全的。为了实现这种转换，各类需要提供强制类型转换的宏，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define ACCEL(obj) \</span><br><span class="line">    OBJECT_CHECK(AccelState, (obj), TYPE_ACCEL)</span><br><span class="line"></span><br><span class="line">#define OBJECT_CHECK(type, obj, name) \</span><br><span class="line">    ((type *)object_dynamic_cast_assert(OBJECT(obj), (name), \</span><br><span class="line">                                        __FILE__, __LINE__, __func__))</span><br></pre></td></tr></table></figure></p>
<p>如果类实例对象指针的name和目标子类实例的name一致，或类实例对象指针是目标子类的祖先，则执行转换，否则 abort。<br>反过来，从子类实例指针转换为父类实例指针是安全的，因为类实例的第一项就指向父类实例，访问时不会存在越界等问题。</p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>属性分为类对象(ObjectClass)属性和类实例对象(Object)属性，存储于 properties 成员中。properties 是一个 GHashTable ，存储了属性名到ObjectProperty的映射。</p>
<h4 id="属性模版"><a href="#属性模版" class="headerlink" title="属性模版"></a>属性模版</h4><p>用于创建属性对象 ObjectProperty<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct Property &#123;</span><br><span class="line">    const char   *name;</span><br><span class="line">    PropertyInfo *info;</span><br><span class="line">    ptrdiff_t    offset;</span><br><span class="line">    uint8_t      bitnr;</span><br><span class="line">    QType        qtype;</span><br><span class="line">    int64_t      defval;</span><br><span class="line">    int          arrayoffset;</span><br><span class="line">    PropertyInfo *arrayinfo;</span><br><span class="line">    int          arrayfieldsize;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="属性对象"><a href="#属性对象" class="headerlink" title="属性对象"></a>属性对象</h4><p>属性对象包含属性名称、类型、描述，类型对应的属性结构，以及相应访问函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef struct ObjectProperty</span><br><span class="line">&#123;</span><br><span class="line">    gchar *name;</span><br><span class="line">    gchar *type;</span><br><span class="line">    gchar *description;</span><br><span class="line">    ObjectPropertyAccessor *get;</span><br><span class="line">    ObjectPropertyAccessor *set;</span><br><span class="line">    ObjectPropertyResolve *resolve;</span><br><span class="line">    ObjectPropertyRelease *release;</span><br><span class="line">    void *opaque;</span><br><span class="line">&#125; ObjectProperty;</span><br></pre></td></tr></table></figure></p>
<p>如对于bool类型的属性，opaque为 BoolProperty ，set为 property_set_bool ，get为 property_get_bool 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct BoolProperty</span><br><span class="line">&#123;</span><br><span class="line">    bool (*get)(Object *, Error **);</span><br><span class="line">    void (*set)(Object *, bool, Error **);</span><br><span class="line">&#125; BoolProperty;</span><br></pre></td></tr></table></figure></p>
<p>用于保存用户传入的 getter 和 setter 。</p>
<h4 id="getter-setter-callback-hook"><a href="#getter-setter-callback-hook" class="headerlink" title="getter / setter (callback hook)"></a>getter / setter (callback hook)</h4><p>定义了在设置/读取属性时触发的函数。<br>比如 device 类型的 instance_init 即 device_initfn 中，定义了 realized 属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object_property_add_bool(obj, &quot;realized&quot;, device_get_realized, device_set_realized, NULL)</span><br></pre></td></tr></table></figure></p>
<p>则 getter 为 device_get_realized ， setter 为 device_set_realized</p>
<h4 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h4><p>凡是在代码中就已经定义好名称和类型的属性，都是静态属性。包括在初始化过程中添加 和 props 。</p>
<h5 id="初始化过程中添加"><a href="#初始化过程中添加" class="headerlink" title="初始化过程中添加"></a>初始化过程中添加</h5><p>比如对于 TypeInfo x86_cpu_type_info ，类实例初始化函数 x86_cpu_initfn 定义好了属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">object_property_add(obj, &quot;family&quot;, &quot;int&quot;,</span><br><span class="line">                    x86_cpuid_version_get_family,</span><br><span class="line">                    x86_cpuid_version_set_family, NULL, NULL, NULL);</span><br><span class="line"></span><br><span class="line">object_property_add_alias(obj, &quot;kvm_steal_time&quot;, obj, &quot;kvm-steal-time&quot;, &amp;error_abort);</span><br></pre></td></tr></table></figure></p>
<p>该属性会直接加到类实例对象的properties中。</p>
<h5 id="props"><a href="#props" class="headerlink" title="props"></a>props</h5><p>一些类对象会在 class_init 中设置 props 成员，比如 TypeInfo host_x86_cpu_type_info 在 host_x86_cpu_class_init 设置为 host_x86_cpu_properties：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static Property host_x86_cpu_properties[] = &#123;</span><br><span class="line">    DEFINE_PROP_BOOL(&quot;migratable&quot;, X86CPU, migratable, true),</span><br><span class="line">    DEFINE_PROP_BOOL(&quot;host-cache-info&quot;, X86CPU, cache_info_passthrough, false),</span><br><span class="line">    DEFINE_PROP_END_OF_LIST()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#define DEFINE_PROP_BOOL(_name, _state, _field, _defval) &#123;       \</span><br><span class="line">        .name      = (_name),                                    \</span><br><span class="line">        .info      = &amp;(qdev_prop_bool),                          \</span><br><span class="line">        .offset    = offsetof(_state, _field)                    \</span><br><span class="line">            + type_check(bool, typeof_field(_state, _field)),    \</span><br><span class="line">        .qtype     = QTYPE_QBOOL,                                \</span><br><span class="line">        .defval    = (bool)_defval,                              \</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">// 闭包</span><br><span class="line">PropertyInfo qdev_prop_bool = &#123;</span><br><span class="line">    .name  = &quot;bool&quot;,</span><br><span class="line">    .get   = get_bool,</span><br><span class="line">    .set   = set_bool,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>而类实例 X86CPU 中定义了这些属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct X86CPU &#123;</span><br><span class="line">    bool migratable;</span><br><span class="line">    ...</span><br><span class="line">    bool cache_info_passthrough;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>于是 X86CPU.migratable 和 X86CPU.cache_info_passthrough 两个成员被定义成属性。</p>
<p>在父类 device_type_info 的类实例初始化函数 device_initfn 中，对所有的props，有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">    for (prop = DEVICE_CLASS(class)-&gt;props; prop &amp;&amp; prop-&gt;name; prop++) &#123;</span><br><span class="line">        qdev_property_add_legacy(dev, prop, &amp;error_abort);</span><br><span class="line">        qdev_property_add_static(dev, prop, &amp;error_abort);</span><br><span class="line">    &#125;</span><br><span class="line">    class = object_class_get_parent(class);</span><br><span class="line">&#125; while (class != object_class_by_name(TYPE_DEVICE));</span><br></pre></td></tr></table></figure></p>
<p>而 qdev_property_add_static ：</p>
<p><pre><br>=&gt; object_property_add(obj, prop-&gt;name, prop-&gt;info-&gt;name, prop-&gt;info-&gt;get, prop-&gt;info-&gt;set, prop-&gt;info-&gt;release, prop, &amp;local_err)<br>    根据Property中的数据，创建ObjectProperty，并将其加到类实例对象的 properties 中<br>    关键是将闭包中的get和set取出，作为ObjectProperty的get和set<br>=&gt; object_property_set_description     设置属性的描述字符串<br>=&gt; 设置属性的默认值<br></pre></p>
<h5 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h5><p>可通过命令查看设备的静态属性，参数为设备 TypeInfo 的 name：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/home/binss/work/qemu/qemu-2.8.1.1/x86_64-softmmu/qemu-system-x86_64 -device Broadwell-x86_64-cpu,?</span><br></pre></td></tr></table></figure></p>
<p>但是， x86_64-cpu 抽象设备无法打。 host-x86_64-cpu 无法列出。</p>
<h4 id="动态属性"><a href="#动态属性" class="headerlink" title="动态属性"></a>动态属性</h4><p>指在运行时动态进行添加的属性。比如用户通过参数传入了一个设备，需要作为属性和其它设备关联起来。<br>典型的动态属性就是 child&lt;&gt; 和 link&lt;&gt; (因为其类型就是这样构造的，后文简称child和link) 。</p>
<h5 id="child"><a href="#child" class="headerlink" title="child"></a>child</h5><p>child实现了composition关系，表示一个设备(parent)创建了另外一个设备(child)，parent掌控child的生命周期，负责向其发送事件。一个device只能有一个parent，但能有多个child。这样就构成一棵组合树。<br>通过 object_property_add_child 添加child：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">=&gt; object_property_add            将 child 作为 obj 的属性，属性名name，类型为 &quot;child&lt;child的类名&gt;&quot;，同时getter为object_get_child_property，没有setter</span><br><span class="line">=&gt; child-&gt;parent = obj</span><br></pre></td></tr></table></figure></p>
<p>例如 x86_cpu_realizefn =&gt; x86_cpu_apic_create =&gt; object_property_add_child(OBJECT(cpu), “lapic”, OBJECT(cpu-&gt;apic_state), &amp;error_abort) 将创建 APICCommonState ，并设置为 X86CPU 的child。<br>可以在qemu hmp查询到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(qemu) info qom-tree</span><br><span class="line">/machine (pc-q35-2.8-machine)</span><br><span class="line">  /unattached (container)</span><br><span class="line">    /device[0] (host-x86_64-cpu)</span><br></pre></td></tr></table></figure></p>
<h5 id="link"><a href="#link" class="headerlink" title="link"></a>link</h5><p>link实现了backlink关系，表示一个设备引用了另外一个设备，是一种松散的联系。两个设备之间能有多个link关系，可以进行修改。它完善了组合树，使其构成构成了一幅有向图。<br>通过 object_property_add_link 添加link：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">=&gt; 创建 LinkProperty ，填充目标(child)的信息</span><br><span class="line">=&gt; object_property_add            将 LinkProperty 作为 obj 的属性，属性名name，类型为 &quot;link&lt;child的类名&gt;&quot;，同时getter为 object_get_link_property 。如果传入了check函数，则需要回调，设置setter为 object_set_link_property</span><br></pre></td></tr></table></figure></p>
<p>例如 q35 有以下link：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">static void q35_host_initfn(Object *obj)</span><br><span class="line">&#123;</span><br><span class="line">    object_property_add_link(obj, MCH_HOST_PROP_RAM_MEM, TYPE_MEMORY_REGION,</span><br><span class="line">                             (Object **) &amp;s-&gt;mch.ram_memory,</span><br><span class="line">                             qdev_prop_allow_set_link_before_realize, 0, NULL);</span><br><span class="line"></span><br><span class="line">    object_property_add_link(obj, MCH_HOST_PROP_PCI_MEM, TYPE_MEMORY_REGION,</span><br><span class="line">                             (Object **) &amp;s-&gt;mch.pci_address_space,</span><br><span class="line">                             qdev_prop_allow_set_link_before_realize, 0, NULL);</span><br><span class="line"></span><br><span class="line">    object_property_add_link(obj, MCH_HOST_PROP_SYSTEM_MEM, TYPE_MEMORY_REGION,</span><br><span class="line">                             (Object **) &amp;s-&gt;mch.system_memory,</span><br><span class="line">                             qdev_prop_allow_set_link_before_realize, 0, NULL);</span><br><span class="line"></span><br><span class="line">    object_property_add_link(obj, MCH_HOST_PROP_IO_MEM, TYPE_MEMORY_REGION,</span><br><span class="line">                             (Object **) &amp;s-&gt;mch.address_space_io,</span><br><span class="line">                             qdev_prop_allow_set_link_before_realize, 0, NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将 Q35PCIHost 和 ram_memory / pci_address_space / system_memory / address_space_io 链接起来。</p>
<h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><p>根据前面所述，属性有两种定义方式，一种是通过 <code>DEFINE_PROP_*</code> 定义，另一种是通过 <code>object_property_add_&lt;type&gt;</code> 进行定义。根据不同的定义方式，set会不同，设置值的方式也有所不同。</p>
<h5 id="object-property-set-lt-type-gt"><a href="#object-property-set-lt-type-gt" class="headerlink" title="object_property_set_&lt;type&gt;"></a><code>object_property_set_&lt;type&gt;</code></h5><p>用于设置某个属性的值。比如 object_property_set_bool ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">=&gt; qbool_from_bool                                              将要设置的值包装成相应的 QObject ，这里是QBool</span><br><span class="line">=&gt; object_property_set_qobject</span><br><span class="line">    =&gt; qobject_input_visitor_new                                将传入的QObject包装成Visitor，其中含各类型的处理函数</span><br><span class="line">    =&gt; object_property_set =&gt; object_property_find              从props的hash table中找到对应的 ObjectProperty</span><br><span class="line">                           =&gt; prop-&gt;set</span><br></pre></td></tr></table></figure></p>
<p>对于 DEFINE_PROP_BOOL 创建的属性来说，其闭包为qdev_prop_bool，因此在初始化时 set 被设置为 set_bool<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set_bool</span><br><span class="line">=&gt; qdev_get_prop_ptr                                                                       将设备指针加上属性值在其中的偏移量，得到属性值的地址</span><br><span class="line">=&gt; visit_type_bool =&gt; v-&gt;type_bool (qobject_input_type_bool) =&gt; qobject_input_get_object   从Visitor中取出QObject</span><br><span class="line">                                                             =&gt; qbool_get_bool             从QObject中取出值，设置到属性值的地址</span><br></pre></td></tr></table></figure></p>
<p>对于 object_property_add_bool 创建的属性来说，它在 object_property_add 时设置 set 为 property_set_bool<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">property_set_bool</span><br><span class="line">=&gt; visit_type_bool =&gt; v-&gt;type_bool (qobject_input_type_bool) =&gt; qobject_input_get_object  找到QObject</span><br><span class="line">=&gt; (BoolProperty)prop-&gt;set    调用setter</span><br></pre></td></tr></table></figure></p>
<p>比如 device 类型的 instance_init 即 device_initfn 中，定义了 realized 属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object_property_add_bool(obj, &quot;realized&quot;, device_get_realized, device_set_realized, NULL)</span><br></pre></td></tr></table></figure></p>
<p>于是 setter 为 device_set_realized<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">=&gt; dc-&gt;realize                                      调用realize函数，其在 class_init 中定义</span><br><span class="line">=&gt; dev-&gt;realized = value                            设置类实例对象的成员</span><br></pre></td></tr></table></figure></p>
<p>一句话总结，前者的属性值的设置由 type_bool 负责设置，而后者由 setter 负责设置。</p>
<h5 id="object-property-get-lt-type-gt"><a href="#object-property-get-lt-type-gt" class="headerlink" title="object_property_get_&lt;type&gt;"></a><code>object_property_get_&lt;type&gt;</code></h5><p>用于读取某个属性的值。比如 object_property_get_bool ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">=&gt; object_property_get_qobject</span><br><span class="line">    =&gt; 创建空的QObject指针</span><br><span class="line">    =&gt; qobject_output_visitor_new                                                           将传入的QObject包装成Visitor，其中含各类型的处理函数</span><br><span class="line">    =&gt; object_property_get =&gt; object_property_find                                          从props的hash table中找到对应的 ObjectProperty</span><br><span class="line">                           =&gt; prop-&gt;get                                                     调用get函数，设置QObject</span><br><span class="line">=&gt; qobject_to_qbool                                                                         将QObject转成QBool</span><br><span class="line">=&gt; qbool_get_bool                                                                           从QBool中取出值，返回</span><br></pre></td></tr></table></figure></p>
<p>对于 DEFINE_PROP_BOOL 创建的属性来说，其闭包为qdev_prop_bool，因此在初始化时 get 被设置为 get_bool<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">get_bool</span><br><span class="line">=&gt; qdev_get_prop_ptr(dev, prop)                                                             将设备指针加上属性值在其中的偏移量，得到属性值的地址</span><br><span class="line">=&gt; visit_type_bool =&gt; v-&gt;type_bool (qobject_output_type_bool) =&gt; qobject_input_get_object   将属性值包装成QObject</span><br></pre></td></tr></table></figure></p>
<p>对于 object_property_add_bool 创建的属性来说，它在 object_property_add 时设置 get 为 property_get_bool ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">property_get_bool</span><br><span class="line">=&gt; prop-&gt;get                                                                                调用getter，得到属性值</span><br><span class="line">=&gt; visit_type_bool =&gt; v-&gt;type_bool (qobject_output_type_bool) =&gt; qobject_input_get_object   将属性值包装成QObject</span><br></pre></td></tr></table></figure></p>
<p>个人的理解是，set 和 get 都需要通过 QObject 和 Visitor 两层包装。前者把要设置属性值包装成QObject再到Visitor，然后再取出设置到相应地址。后者根据属性值地址将属性值包装成QObject，设置为Visitor中QObject指针指向，然后再从QObject中取出值。</p>
<h5 id="object-property-parse"><a href="#object-property-parse" class="headerlink" title="object_property_parse"></a>object_property_parse</h5><p>在用一个string设置不知道类型的属性的值时，使用 object_property_parse：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void object_property_parse(Object *obj, const char *string,</span><br><span class="line">                           const char *name, Error **errp)</span><br><span class="line">&#123;</span><br><span class="line">    Visitor *v = string_input_visitor_new(string);</span><br><span class="line">    object_property_set(obj, v, name, errp);</span><br><span class="line">    visit_free(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>它会创建一个 Visitor 并将值设置到里面，这里定义了string转其他类型属性的函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">v-&gt;visitor.type = VISITOR_INPUT;</span><br><span class="line">v-&gt;visitor.type_int64 = parse_type_int64;</span><br><span class="line">v-&gt;visitor.type_uint64 = parse_type_uint64;</span><br><span class="line">v-&gt;visitor.type_size = parse_type_size;</span><br><span class="line">v-&gt;visitor.type_bool = parse_type_bool;</span><br><span class="line">v-&gt;visitor.type_str = parse_type_str;</span><br><span class="line">v-&gt;visitor.type_number = parse_type_number;</span><br></pre></td></tr></table></figure></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>如此一来，根据 TypeInfo 创建了 TypeImpl ，然后根据 TypeImpl 创建了对应的 ObjectClass ，再根据 TypeImpl 创建了对应的 Object ， ObjectClass 和 Object 都有自己的 Property，关系如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">                TypeImpl</span><br><span class="line">                class      -&gt;  ObjectClass(AccelClass)    Object(AccelState)</span><br><span class="line">                           &lt;-       type            &lt;-         class</span><br><span class="line">TypeImpl  &lt;-  parent_type    properties(GHashTable)     properties(GHashTable)</span><br></pre></td></tr></table></figure></p>

    </div>

    
    
    
        <div class="reward-container">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    Donate
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="Yi颗烂樱桃 WeChat Pay">
        <p>WeChat Pay</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="Yi颗烂樱桃 Alipay">
        <p>Alipay</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/QEMU/" rel="tag"># QEMU</a>
              <a href="/tags/QOM/" rel="tag"># QOM</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2018/12/24/qemu-debug/" rel="prev" title="使用 QEMU 调试内核">
      <i class="fa fa-chevron-left"></i> 使用 QEMU 调试内核
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/01/29/Intel-SDM/" rel="next" title="英特尔®64和IA-32架构软件开发人员手册(Intel SDM)">
      英特尔®64和IA-32架构软件开发人员手册(Intel SDM) <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是QOM"><span class="nav-number">1.</span> <span class="nav-text">什么是QOM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#QOM-的初始化"><span class="nav-number">2.</span> <span class="nav-text">QOM 的初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用QOM添加设备源码分析"><span class="nav-number">3.</span> <span class="nav-text">使用QOM添加设备源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TypeInfo-gt-ModuleEntry"><span class="nav-number">3.1.</span> <span class="nav-text">TypeInfo =&gt; ModuleEntry</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ModuleEntry-gt-TypeImpl"><span class="nav-number">3.2.</span> <span class="nav-text">ModuleEntry =&gt; TypeImpl</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ObjectClass"><span class="nav-number">3.3.</span> <span class="nav-text">ObjectClass</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TypeImpl-gt-ObjectClass"><span class="nav-number">3.3.1.</span> <span class="nav-text">TypeImpl =&gt; ObjectClass</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#继承"><span class="nav-number">3.3.2.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#强制类型转换"><span class="nav-number">3.3.3.</span> <span class="nav-text">强制类型转换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object"><span class="nav-number">3.4.</span> <span class="nav-text">Object</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#创建流程"><span class="nav-number">3.4.1.</span> <span class="nav-text">创建流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#继承-1"><span class="nav-number">3.4.2.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#强制类型转换-1"><span class="nav-number">3.4.3.</span> <span class="nav-text">强制类型转换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#属性"><span class="nav-number">3.5.</span> <span class="nav-text">属性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#属性模版"><span class="nav-number">3.5.1.</span> <span class="nav-text">属性模版</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#属性对象"><span class="nav-number">3.5.2.</span> <span class="nav-text">属性对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#getter-setter-callback-hook"><span class="nav-number">3.5.3.</span> <span class="nav-text">getter / setter (callback hook)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#静态属性"><span class="nav-number">3.5.4.</span> <span class="nav-text">静态属性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#初始化过程中添加"><span class="nav-number">3.5.4.1.</span> <span class="nav-text">初始化过程中添加</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#props"><span class="nav-number">3.5.4.2.</span> <span class="nav-text">props</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#查看"><span class="nav-number">3.5.4.3.</span> <span class="nav-text">查看</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#动态属性"><span class="nav-number">3.5.5.</span> <span class="nav-text">动态属性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#child"><span class="nav-number">3.5.5.1.</span> <span class="nav-text">child</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#link"><span class="nav-number">3.5.5.2.</span> <span class="nav-text">link</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#API"><span class="nav-number">3.5.6.</span> <span class="nav-text">API</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#object-property-set-lt-type-gt"><span class="nav-number">3.5.6.1.</span> <span class="nav-text">object_property_set_&lt;type&gt;</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#object-property-get-lt-type-gt"><span class="nav-number">3.5.6.2.</span> <span class="nav-text">object_property_get_&lt;type&gt;</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#object-property-parse"><span class="nav-number">3.5.6.3.</span> <span class="nav-text">object_property_parse</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">3.6.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yi颗烂樱桃" src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Yi颗烂樱桃</p>
  <div class="site-description" itemprop="description">这是一颗烂樱桃的技术博客，一个微不足道的魔都程序员，或者是自以为的程序员</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">46</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2018 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-snowflake-o"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yi颗烂樱桃</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>

  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>


  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  <script src="/js/local-search.js"></script>












  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '30a5af43b5ea724ad81b',
      clientSecret: '3426c0800920f9f75967ecf4b87f453e8012b911',
      repo        : 'ysun.github.io',
      owner       : 'ysun',
      admin       : ['ysun'],
      id          : 'cfadf79c5666f070f9fc582357c86664',
        language: '',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
