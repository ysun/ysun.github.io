<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.8.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.owalle.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="虚拟机启动过程1234567891011121314151617181920212223第一步，获取到kvm句柄kvmfd = open(&amp;quot;/dev/kvm&amp;quot;, O_RDWR);第二步，创建虚拟机，获取到虚拟机句柄。vmfd = ioctl(kvmfd, KVM_CREATE_VM, 0);第三步，为虚拟机映射内存，还有其他的PCI，信号处理的初始化。ioctl(vmfd, K">
<meta name="keywords" content="KVM">
<meta property="og:type" content="article">
<meta property="og:title" content="KVM 虚拟化原理2— QEMU启动过程">
<meta property="og:url" content="http://www.owalle.com/2018/12/10/kvm-boot/index.html">
<meta property="og:site_name" content="Yi颗烂樱桃">
<meta property="og:description" content="虚拟机启动过程1234567891011121314151617181920212223第一步，获取到kvm句柄kvmfd = open(&amp;quot;/dev/kvm&amp;quot;, O_RDWR);第二步，创建虚拟机，获取到虚拟机句柄。vmfd = ioctl(kvmfd, KVM_CREATE_VM, 0);第三步，为虚拟机映射内存，还有其他的PCI，信号处理的初始化。ioctl(vmfd, K">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2021-09-27T09:54:43.122Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="KVM 虚拟化原理2— QEMU启动过程">
<meta name="twitter:description" content="虚拟机启动过程1234567891011121314151617181920212223第一步，获取到kvm句柄kvmfd = open(&amp;quot;/dev/kvm&amp;quot;, O_RDWR);第二步，创建虚拟机，获取到虚拟机句柄。vmfd = ioctl(kvmfd, KVM_CREATE_VM, 0);第三步，为虚拟机映射内存，还有其他的PCI，信号处理的初始化。ioctl(vmfd, K">

<link rel="canonical" href="http://www.owalle.com/2018/12/10/kvm-boot/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>KVM 虚拟化原理2— QEMU启动过程 | Yi颗烂樱桃</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Yi颗烂樱桃</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">虚拟化中文</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-fw fa-sitemap"></i>Sitemap</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" placeholder="Searching..." spellcheck="false" type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope="" itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://www.owalle.com/2018/12/10/kvm-boot/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yi颗烂樱桃">
      <meta itemprop="description" content="这是一颗烂樱桃的技术博客，一个微不足道的魔都程序员，或者是自以为的程序员">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yi颗烂樱桃">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          KVM 虚拟化原理2— QEMU启动过程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-12-10 22:57:17" itemprop="dateCreated datePublished" datetime="2018-12-10T22:57:17+08:00">2018-12-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-09-27 17:54:43" itemprop="dateModified" datetime="2021-09-27T17:54:43+08:00">2021-09-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/KVM/" itemprop="url" rel="index"><span itemprop="name">KVM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="虚拟机启动过程"><a href="#虚拟机启动过程" class="headerlink" title="虚拟机启动过程"></a>虚拟机启动过程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">第一步，获取到kvm句柄</span><br><span class="line">kvmfd = open(&quot;/dev/kvm&quot;, O_RDWR);</span><br><span class="line"></span><br><span class="line">第二步，创建虚拟机，获取到虚拟机句柄。</span><br><span class="line">vmfd = ioctl(kvmfd, KVM_CREATE_VM, 0);</span><br><span class="line"></span><br><span class="line">第三步，为虚拟机映射内存，还有其他的PCI，信号处理的初始化。</span><br><span class="line">ioctl(vmfd, KVM_SET_USER_MEMORY_REGION, &amp;mem);</span><br><span class="line"></span><br><span class="line">第四步，创建vCPU</span><br><span class="line">vcpufd = ioctl(vmfd, KVM_CREATE_VCPU, vcpuio)</span><br><span class="line"></span><br><span class="line">第五步，为vCPU分配内存</span><br><span class="line">vcpu_size=ioctl(kvmfd, KVM_GET_VCPU_MMAP_SIZE, NULL)</span><br><span class="line">run = (struct kvm_run*)mmap(NULL, mmap_size, PROT_READ|PROT_WRITE, MAP_SHARED, vcpufd, 0)</span><br><span class="line"></span><br><span class="line">第六步，创建vCPU个数的线程并运行虚拟机。</span><br><span class="line">ioctl(vcpufd, KVM_RUN, 0);</span><br><span class="line">将汇编代码加载到用户内存中，并且设置vCPU的寄存器，例如RIP</span><br><span class="line"></span><br><span class="line">第七步，线程进入循环，并捕获虚拟机退出原因，做相应的处理。</span><br><span class="line">while(1) &#123; ioctl(kvm-&gt;vcpus-&gt;vcpu_fd, KVM_RUN, 0); &#125;;</span><br><span class="line">这里的退出并不一定是虚拟机关机，虚拟机如果遇到IO操作，访问硬件设备，缺页中断等都会退出执行，退出执行可以理解为将CPU执行上下文返回到QEMU。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">open(&quot;/dev/kvm&quot;)</span><br><span class="line">ioctl(KVM_CREATE_VM)</span><br><span class="line">ioctl(KVM_CREATE_VCPU)</span><br><span class="line">for (;;) &#123;</span><br><span class="line">     ioctl(KVM_RUN)</span><br><span class="line">     switch (exit_reason) &#123;</span><br><span class="line">     case KVM_EXIT_IO:  /* ... */</span><br><span class="line">     case KVM_EXIT_HLT: /* ... */</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于KVM_CREATE_VM参数的描述，创建的VM是没有cpu和内存的，需要QEMU进程利用mmap系统调用映射一块内存给VM的描述符，其实也就是给VM创建内存的过程。</p>
<p><a href="https://github.com/torvalds/linux/blob/master/Documentation/virtual/kvm/api.txt" target="_blank" rel="noopener">KVM ioctl接口文档</a></p>
<h2 id="先来一个KVM-API开胃菜"><a href="#先来一个KVM-API开胃菜" class="headerlink" title="先来一个KVM API开胃菜"></a>先来一个KVM API开胃菜</h2><p>下面是一个KVM的简单demo，其目的在于加载 code 并使用KVM运行起来.<br>这是一个at&amp;t的8086汇编，.code16表示他是一个16位的，当然直接运行是运行不起来的，为了让他运行起来，我们可以用KVM提供的API，将这个程序看做一个最简单的操作系统，让其运行起来。<br>这个汇编的作用是输出al寄存器的值到0x3f8端口。对于x86架构来说，通过IN/OUT指令访问。PC架构一共有65536个8bit的I/O端口，组成64KI/O地址空间，编号从0~0xFFFF。连续两个8bit的端口可以组成一个16bit的端口，连续4个组成一个32bit的端口。I/O地址空间和CPU的物理地址空间是两个不同的概念，例如I/O地址空间为64K，一个32bit的CPU物理地址空间是4G。<br>最终程序理想的输出应该是，al，bl的值后面KVM初始化的时候有赋值。<br>4\n (并不直接输出\n，而是换了一行），hlt 指令表示虚拟机退出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.globl _start</span><br><span class="line">    .code16</span><br><span class="line">_start:</span><br><span class="line">    mov $0x3f8, %dx</span><br><span class="line">    add %bl, %al</span><br><span class="line">    add $&apos;0&apos;, %al</span><br><span class="line">    out %al, (%dx)</span><br><span class="line">    mov $&apos;\n&apos;, %al</span><br><span class="line">    out %al, (%dx)</span><br><span class="line">    hlt</span><br></pre></td></tr></table></figure>
<p>我们编译一下这个汇编，得到一个 Bin.bin 的二进制文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">as -32 bin.S -o bin.o</span><br><span class="line">ld -m elf_i386 --oformat binary -N -e _start -Ttext 0x10000 -o Bin.bin bin.o</span><br></pre></td></tr></table></figure>
<p>查看一下二进制格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜  demo1 hexdump -C bin.bin</span><br><span class="line">00000000  ba f8 03 00 d8 04 30 ee  b0 0a ee f4              |......0.....|</span><br><span class="line">0000000c</span><br><span class="line">对应了下面的code数组，这样直接加载字节码就不需要再从文件加载了</span><br><span class="line">    const uint8_t code[] = &#123;</span><br><span class="line">        0xba, 0xf8, 0x03, /* mov $0x3f8, %dx */</span><br><span class="line">        0x00, 0xd8,       /* add %bl, %al */</span><br><span class="line">        0x04, &apos;0&apos;,        /* add $&apos;0&apos;, %al */</span><br><span class="line">        0xee,             /* out %al, (%dx) */</span><br><span class="line">        0xb0, &apos;\n&apos;,       /* mov $&apos;\n&apos;, %al */</span><br><span class="line">        0xee,             /* out %al, (%dx) */</span><br><span class="line">        0xf4,             /* hlt */</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;err.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;linux/kvm.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys/ioctl.h&gt;</span><br><span class="line">#include &lt;sys/mman.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int kvm, vmfd, vcpufd, ret;</span><br><span class="line">    const uint8_t code[] = &#123;</span><br><span class="line">        0xba, 0xf8, 0x03, /* mov $0x3f8, %dx */</span><br><span class="line">        0x00, 0xd8,       /* add %bl, %al */</span><br><span class="line">        0x04, &apos;0&apos;,        /* add $&apos;0&apos;, %al */</span><br><span class="line">        0xee,             /* out %al, (%dx) */</span><br><span class="line">        0xb0, &apos;\n&apos;,       /* mov $&apos;\n&apos;, %al */</span><br><span class="line">        0xee,             /* out %al, (%dx) */</span><br><span class="line">        0xf4,             /* hlt */</span><br><span class="line">    &#125;;</span><br><span class="line">    uint8_t *mem;</span><br><span class="line">    struct kvm_sregs sregs;</span><br><span class="line">    size_t mmap_size;</span><br><span class="line">    struct kvm_run *run;</span><br><span class="line"></span><br><span class="line">    // 获取 kvm 句柄 第一步</span><br><span class="line">    kvm = open(&quot;/dev/kvm&quot;, O_RDWR | O_CLOEXEC);</span><br><span class="line">    if (kvm == -1)</span><br><span class="line">        err(1, &quot;/dev/kvm&quot;);</span><br><span class="line"></span><br><span class="line">    // 确保是正确的 API 版本</span><br><span class="line">    ret = ioctl(kvm, KVM_GET_API_VERSION, NULL);</span><br><span class="line">    if (ret == -1)</span><br><span class="line">        err(1, &quot;KVM_GET_API_VERSION&quot;);</span><br><span class="line">    if (ret != 12)</span><br><span class="line">        errx(1, &quot;KVM_GET_API_VERSION %d, expected 12&quot;, ret);</span><br><span class="line"></span><br><span class="line">    // 创建一虚拟机 第二步</span><br><span class="line">    vmfd = ioctl(kvm, KVM_CREATE_VM, (unsigned long)0);</span><br><span class="line">    if (vmfd == -1)</span><br><span class="line">        err(1, &quot;KVM_CREATE_VM&quot;);</span><br><span class="line"></span><br><span class="line">    // 为这个虚拟机申请内存，并将代码（镜像）加载到虚拟机内存中</span><br><span class="line">    mem = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);</span><br><span class="line">    if (!mem)</span><br><span class="line">        err(1, &quot;allocating guest memory&quot;);</span><br><span class="line">    memcpy(mem, code, sizeof(code));</span><br><span class="line"></span><br><span class="line">    // 为什么从 0x1000 开始呢，因为页表空间的前4K是留给页表目录</span><br><span class="line">    struct kvm_userspace_memory_region region = &#123;</span><br><span class="line">        .slot = 0,</span><br><span class="line">        .guest_phys_addr = 0x1000,</span><br><span class="line">        .memory_size = 0x1000,</span><br><span class="line">        .userspace_addr = (uint64_t)mem,</span><br><span class="line">    &#125;;</span><br><span class="line">    // 设置 KVM 的内存区域 第三部</span><br><span class="line">    ret = ioctl(vmfd, KVM_SET_USER_MEMORY_REGION, &amp;region);</span><br><span class="line">    if (ret == -1)</span><br><span class="line">        err(1, &quot;KVM_SET_USER_MEMORY_REGION&quot;);</span><br><span class="line"></span><br><span class="line">    // 创建虚拟CPU 第四部</span><br><span class="line">    vcpufd = ioctl(vmfd, KVM_CREATE_VCPU, (unsigned long)0);</span><br><span class="line">    if (vcpufd == -1)</span><br><span class="line">        err(1, &quot;KVM_CREATE_VCPU&quot;);</span><br><span class="line"></span><br><span class="line">    // 获取 KVM 运行时结构的大小</span><br><span class="line">    ret = ioctl(kvm, KVM_GET_VCPU_MMAP_SIZE, NULL);</span><br><span class="line">    if (ret == -1)</span><br><span class="line">        err(1, &quot;KVM_GET_VCPU_MMAP_SIZE&quot;);</span><br><span class="line">    mmap_size = ret;</span><br><span class="line">    if (mmap_size &lt; sizeof(*run))</span><br><span class="line">        errx(1, &quot;KVM_GET_VCPU_MMAP_SIZE unexpectedly small&quot;);</span><br><span class="line">    // 将 kvm run 与 vcpu 做关联，这样能够获取到kvm的运行时信息 第五步</span><br><span class="line">    run = mmap(NULL, mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED, vcpufd, 0);</span><br><span class="line">    if (!run)</span><br><span class="line">        err(1, &quot;mmap vcpu&quot;);</span><br><span class="line"></span><br><span class="line">    // 获取特殊寄存器  第六步</span><br><span class="line">    ret = ioctl(vcpufd, KVM_GET_SREGS, &amp;sregs);</span><br><span class="line">    if (ret == -1)</span><br><span class="line">        err(1, &quot;KVM_GET_SREGS&quot;);</span><br><span class="line">    // 设置代码段为从地址0处开始，我们的代码被加载到了0x0000的起始位置</span><br><span class="line">    sregs.cs.base = 0;</span><br><span class="line">    sregs.cs.selector = 0;</span><br><span class="line">    // KVM_SET_SREGS 设置特殊寄存器</span><br><span class="line">    ret = ioctl(vcpufd, KVM_SET_SREGS, &amp;sregs);</span><br><span class="line">    if (ret == -1)</span><br><span class="line">        err(1, &quot;KVM_SET_SREGS&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 设置代码的入口地址，相当于32位main函数的地址，这里16位汇编都是由0x1000处开始。</span><br><span class="line">    // 如果是正式的镜像，那么rip的值应该是类似引导扇区加载进来的指令</span><br><span class="line">    struct kvm_regs regs = &#123;</span><br><span class="line">        .rip = 0x1000,</span><br><span class="line">        .rax = 2,    // 设置 ax 寄存器初始值为 2</span><br><span class="line">        .rbx = 2,    // 同理</span><br><span class="line">        .rflags = 0x2,   // 初始化flags寄存器，x86架构下需要设置，否则会粗错</span><br><span class="line">    &#125;;</span><br><span class="line">    ret = ioctl(vcpufd, KVM_SET_REGS, &amp;regs);</span><br><span class="line">    if (ret == -1)</span><br><span class="line">        err(1, &quot;KVM_SET_REGS&quot;);</span><br><span class="line"></span><br><span class="line">    // 开始运行虚拟机，如果是qemu-kvm，会用一个线程来执行这个vCPU，并加载指令 第七步</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        // 开始运行虚拟机</span><br><span class="line">        ret = ioctl(vcpufd, KVM_RUN, NULL);</span><br><span class="line">        if (ret == -1)</span><br><span class="line">            err(1, &quot;KVM_RUN&quot;);</span><br><span class="line">        // 获取虚拟机退出原因</span><br><span class="line">        switch (run-&gt;exit_reason) &#123;</span><br><span class="line">        case KVM_EXIT_HLT:</span><br><span class="line">            puts(&quot;KVM_EXIT_HLT&quot;);</span><br><span class="line">            return 0;</span><br><span class="line">        // 汇编调用了 out 指令，vmx 模式下不允许执行这个操作，所以</span><br><span class="line">        // 将操作权切换到了宿主机，切换的时候会将上下文保存到VMCS寄存器</span><br><span class="line">        // 后面CPU虚拟化会讲到这部分</span><br><span class="line">        // 因为虚拟机的内存宿主机能够直接读取到，所以直接在宿主机上获取到</span><br><span class="line">        // 虚拟机的输出（out指令），这也是后面PCI设备虚拟化的一个基础，DMA模式的PCI设备</span><br><span class="line">        case KVM_EXIT_IO:</span><br><span class="line">            if (run-&gt;io.direction == KVM_EXIT_IO_OUT &amp;&amp; run-&gt;io.size == 1 &amp;&amp; run-&gt;io.port == 0x3f8 &amp;&amp; run-&gt;io.count == 1)</span><br><span class="line">                putchar(*(((char *)run) + run-&gt;io.data_offset));</span><br><span class="line">            else</span><br><span class="line">                errx(1, &quot;unhandled KVM_EXIT_IO&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case KVM_EXIT_FAIL_ENTRY:</span><br><span class="line">            errx(1, &quot;KVM_EXIT_FAIL_ENTRY: hardware_entry_failure_reason = 0x%llx&quot;,</span><br><span class="line">                 (unsigned long long)run-&gt;fail_entry.hardware_entry_failure_reason);</span><br><span class="line">        case KVM_EXIT_INTERNAL_ERROR:</span><br><span class="line">            errx(1, &quot;KVM_EXIT_INTERNAL_ERROR: suberror = 0x%x&quot;, run-&gt;internal.suberror);</span><br><span class="line">        default:</span><br><span class="line">            errx(1, &quot;exit_reason = 0x%x&quot;, run-&gt;exit_reason);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译并运行这个demo</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc -g demo.c -o demo</span><br><span class="line">➜  demo1 ./demo</span><br><span class="line">4</span><br><span class="line">KVM_EXIT_HLT</span><br></pre></td></tr></table></figure>
<h2 id="另外一个简单的QEMU-emulator-demo"><a href="#另外一个简单的QEMU-emulator-demo" class="headerlink" title="另外一个简单的QEMU emulator demo"></a>另外一个简单的QEMU emulator demo</h2><p><a href="http://soulxu.github.io/blog/2014/08/11/use-kvm-api-write-emulator/" target="_blank" rel="noopener">IBM的徐同学有做过介绍</a>，在此基础上我再详细介绍一下qemu-kvm的启动过程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.globl _start</span><br><span class="line">    .code16</span><br><span class="line">_start:</span><br><span class="line">    xorw %ax, %ax   # 将 ax 寄存器清零</span><br><span class="line"></span><br><span class="line">loop1:</span><br><span class="line">    out %ax, $0x10  # 像 0x10 的端口输出 ax 的内容，at&amp;t汇编的操作数和Intel的相反。</span><br><span class="line">    inc %ax         # ax 值加一</span><br><span class="line">    jmp loop1       # 继续循环</span><br></pre></td></tr></table></figure>
<p>这个汇编的作用就是一直不停的向0x10端口输出一字节的值。</p>
<p>从main函数开始说起</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char **argv) &#123;</span><br><span class="line">    int ret = 0;</span><br><span class="line">    // 初始化kvm结构体</span><br><span class="line">    struct kvm *kvm = kvm_init();</span><br><span class="line"></span><br><span class="line">    if (kvm == NULL) &#123;</span><br><span class="line">        fprintf(stderr, &quot;kvm init fauilt\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 创建VM，并分配内存空间</span><br><span class="line">    if (kvm_create_vm(kvm, RAM_SIZE) &lt; 0) &#123;</span><br><span class="line">        fprintf(stderr, &quot;create vm fault\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 加载镜像</span><br><span class="line">    load_binary(kvm);</span><br><span class="line"></span><br><span class="line">    // only support one vcpu now</span><br><span class="line">    kvm-&gt;vcpu_number = 1;</span><br><span class="line">    // 创建执行现场</span><br><span class="line">    kvm-&gt;vcpus = kvm_init_vcpu(kvm, 0, kvm_cpu_thread);</span><br><span class="line"></span><br><span class="line">    // 启动虚拟机</span><br><span class="line">    kvm_run_vm(kvm);</span><br><span class="line"></span><br><span class="line">    kvm_clean_vm(kvm);</span><br><span class="line">    kvm_clean_vcpu(kvm-&gt;vcpus);</span><br><span class="line">    kvm_clean(kvm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一步，调用kvm_init() 初始化了 kvm 结构体。先来看看怎么定义一个简单的kvm。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct kvm &#123;</span><br><span class="line">   int dev_fd;              // /dev/kvm 的句柄</span><br><span class="line">   int vm_fd;               // GUEST 的句柄</span><br><span class="line">   __u64 ram_size;          // GUEST 的内存大小</span><br><span class="line">   __u64 ram_start;         // GUEST 的内存起始地址，</span><br><span class="line">                            // 这个地址是qemu emulator通过mmap映射的地址</span><br><span class="line"></span><br><span class="line">   int kvm_version;         </span><br><span class="line">   struct kvm_userspace_memory_region mem; // slot 内存结构，由用户空间填充、</span><br><span class="line">                                           // 允许对guest的地址做分段。将多个slot组成线性地址</span><br><span class="line"></span><br><span class="line">   struct vcpu *vcpus;      // vcpu 数组</span><br><span class="line">   int vcpu_number;         // vcpu 个数</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>初始化 kvm 结构体。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct kvm *kvm_init(void) &#123;</span><br><span class="line">    struct kvm *kvm = malloc(sizeof(struct kvm));</span><br><span class="line">    kvm-&gt;dev_fd = open(KVM_DEVICE, O_RDWR);  // 打开 /dev/kvm 获取 kvm 句柄</span><br><span class="line"></span><br><span class="line">    if (kvm-&gt;dev_fd &lt; 0) &#123;</span><br><span class="line">        perror(&quot;open kvm device fault: &quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kvm-&gt;kvm_version = ioctl(kvm-&gt;dev_fd, KVM_GET_API_VERSION, 0);  // 获取 kvm API 版本</span><br><span class="line"></span><br><span class="line">    return kvm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二步+第三步，创建虚拟机，获取到虚拟机句柄，并为其分配内存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">int kvm_create_vm(struct kvm *kvm, int ram_size) &#123;</span><br><span class="line">    int ret = 0;</span><br><span class="line">    // 调用 KVM_CREATE_KVM 接口获取 vm 句柄</span><br><span class="line">    kvm-&gt;vm_fd = ioctl(kvm-&gt;dev_fd, KVM_CREATE_VM, 0);</span><br><span class="line"></span><br><span class="line">    if (kvm-&gt;vm_fd &lt; 0) &#123;</span><br><span class="line">        perror(&quot;can not create vm&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 为 kvm 分配内存。通过系统调用.</span><br><span class="line">    kvm-&gt;ram_size = ram_size;</span><br><span class="line">    kvm-&gt;ram_start =  (__u64)mmap(NULL, kvm-&gt;ram_size, </span><br><span class="line">                PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_NORESERVE, </span><br><span class="line">                -1, 0);</span><br><span class="line"></span><br><span class="line">    if ((void *)kvm-&gt;ram_start == MAP_FAILED) &#123;</span><br><span class="line">        perror(&quot;can not mmap ram&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // kvm-&gt;mem 结构需要初始化后传递给 KVM_SET_USER_MEMORY_REGION 接口</span><br><span class="line">    // 只有一个内存槽</span><br><span class="line">    kvm-&gt;mem.slot = 0;</span><br><span class="line">    // guest 物理内存起始地址</span><br><span class="line">    kvm-&gt;mem.guest_phys_addr = 0;</span><br><span class="line">    // 虚拟机内存大小</span><br><span class="line">    kvm-&gt;mem.memory_size = kvm-&gt;ram_size;</span><br><span class="line">    // 虚拟机内存在host上的用户空间地址，这里就是绑定内存给guest</span><br><span class="line">    kvm-&gt;mem.userspace_addr = kvm-&gt;ram_start;</span><br><span class="line"></span><br><span class="line">    // 调用 KVM_SET_USER_MEMORY_REGION 为虚拟机分配内存。</span><br><span class="line">    ret = ioctl(kvm-&gt;vm_fd, KVM_SET_USER_MEMORY_REGION, &amp;(kvm-&gt;mem));</span><br><span class="line"></span><br><span class="line">    if (ret &lt; 0) &#123;</span><br><span class="line">        perror(&quot;can not set user memory region&quot;);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来就是load_binary把二进制文件load到虚拟机的内存中来，在第一个demo中我们是直接把字节码放到了内存中，这里模拟镜像加载步骤，把二进制文件加载到内存中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void load_binary(struct kvm *kvm) &#123;</span><br><span class="line">    int fd = open(BINARY_FILE, O_RDONLY);  // 打开这个二进制文件(镜像）</span><br><span class="line"></span><br><span class="line">    if (fd &lt; 0) &#123;</span><br><span class="line">        fprintf(stderr, &quot;can not open binary file\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int ret = 0;</span><br><span class="line">    char *p = (char *)kvm-&gt;ram_start;</span><br><span class="line"></span><br><span class="line">    while(1) &#123;</span><br><span class="line">        ret = read(fd, p, 4096);           // 将镜像内容加载到虚拟机的内存中</span><br><span class="line">        if (ret &lt;= 0) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;read size: %d&quot;, ret);</span><br><span class="line">        p += ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加载完镜像后，需要初始化vCPU，以便能够运行镜像内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">struct vcpu &#123;</span><br><span class="line">    int vcpu_id;                 // vCPU id，vCPU</span><br><span class="line">    int vcpu_fd;                 // vCPU 句柄</span><br><span class="line">    pthread_t vcpu_thread;       // vCPU 线程句柄</span><br><span class="line">    struct kvm_run *kvm_run;     // KVM 运行时结构，也可以看做是上下文</span><br><span class="line">    int kvm_run_mmap_size;       // 运行时结构大小</span><br><span class="line">    struct kvm_regs regs;        // vCPU的寄存器</span><br><span class="line">    struct kvm_sregs sregs;      // vCPU的特殊寄存器</span><br><span class="line">    void *(*vcpu_thread_func)(void *);  // 线程执行函数</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct vcpu *kvm_init_vcpu(struct kvm *kvm, int vcpu_id, void *(*fn)(void *)) &#123;</span><br><span class="line">    // 申请vcpu结构</span><br><span class="line">    struct vcpu *vcpu = malloc(sizeof(struct vcpu));</span><br><span class="line">    // 只有一个 vCPU，所以这里只初始化一个</span><br><span class="line">    vcpu-&gt;vcpu_id = 0;</span><br><span class="line">    // 调用 KVM_CREATE_VCPU 获取 vCPU 句柄，并关联到kvm-&gt;vm_fd（由KVM_CREATE_VM返回）</span><br><span class="line">    vcpu-&gt;vcpu_fd = ioctl(kvm-&gt;vm_fd, KVM_CREATE_VCPU, vcpu-&gt;vcpu_id);</span><br><span class="line"></span><br><span class="line">    if (vcpu-&gt;vcpu_fd &lt; 0) &#123;</span><br><span class="line">        perror(&quot;can not create vcpu&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取KVM运行时结构大小</span><br><span class="line">    vcpu-&gt;kvm_run_mmap_size = ioctl(kvm-&gt;dev_fd, KVM_GET_VCPU_MMAP_SIZE, 0);</span><br><span class="line"></span><br><span class="line">    if (vcpu-&gt;kvm_run_mmap_size &lt; 0) &#123;</span><br><span class="line">        perror(&quot;can not get vcpu mmsize&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;%d\n&quot;, vcpu-&gt;kvm_run_mmap_size);</span><br><span class="line">    // 将 vcpu_fd 的内存映射给 vcpu-&gt;kvm_run结构。相当于一个关联操作</span><br><span class="line">    // 以便能够在虚拟机退出的时候获取到vCPU的返回值等信息</span><br><span class="line">    vcpu-&gt;kvm_run = mmap(NULL, vcpu-&gt;kvm_run_mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED, vcpu-&gt;vcpu_fd, 0);</span><br><span class="line"></span><br><span class="line">    if (vcpu-&gt;kvm_run == MAP_FAILED) &#123;</span><br><span class="line">        perror(&quot;can not mmap kvm_run&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 设置线程执行函数</span><br><span class="line">    vcpu-&gt;vcpu_thread_func = fn;</span><br><span class="line">    return vcpu;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后一步，以上工作就绪后，启动虚拟机。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void kvm_run_vm(struct kvm *kvm) &#123;</span><br><span class="line">    int i = 0;</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; kvm-&gt;vcpu_number; i++) &#123;</span><br><span class="line">        // 启动线程执行 vcpu_thread_func 并将 kvm 结构作为参数传递给线程</span><br><span class="line">        if (pthread_create(&amp;(kvm-&gt;vcpus-&gt;vcpu_thread), (const pthread_attr_t *)NULL, kvm-&gt;vcpus[i].vcpu_thread_func, kvm) != 0) &#123;</span><br><span class="line">            perror(&quot;can not create kvm thread&quot;);</span><br><span class="line">            exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_join(kvm-&gt;vcpus-&gt;vcpu_thread, NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动虚拟机其实就是创建线程，并执行相应的线程回调函数。<br>线程回调函数在kvm_init_vcpu的时候传入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">void *kvm_cpu_thread(void *data) &#123;</span><br><span class="line">    // 获取参数</span><br><span class="line">    struct kvm *kvm = (struct kvm *)data;</span><br><span class="line">    int ret = 0;</span><br><span class="line">    // 设置KVM的参数</span><br><span class="line">    kvm_reset_vcpu(kvm-&gt;vcpus);</span><br><span class="line"></span><br><span class="line">    while (1) &#123;</span><br><span class="line">        printf(&quot;KVM start run\n&quot;);</span><br><span class="line">        // 启动虚拟机，此时的虚拟机已经有内存和CPU了，可以运行起来了。</span><br><span class="line">        ret = ioctl(kvm-&gt;vcpus-&gt;vcpu_fd, KVM_RUN, 0);</span><br><span class="line"></span><br><span class="line">        if (ret &lt; 0) &#123;</span><br><span class="line">            fprintf(stderr, &quot;KVM_RUN failed\n&quot;);</span><br><span class="line">            exit(1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 前文 kvm_init_vcpu 函数中，将 kvm_run 关联了 vCPU 结构的内存</span><br><span class="line">        // 所以这里虚拟机退出的时候，可以获取到 exit_reason，虚拟机退出原因</span><br><span class="line">        switch (kvm-&gt;vcpus-&gt;kvm_run-&gt;exit_reason) &#123;</span><br><span class="line">        case KVM_EXIT_UNKNOWN:</span><br><span class="line">            printf(&quot;KVM_EXIT_UNKNOWN\n&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case KVM_EXIT_DEBUG:</span><br><span class="line">            printf(&quot;KVM_EXIT_DEBUG\n&quot;);</span><br><span class="line">            break;</span><br><span class="line">        // 虚拟机执行了IO操作，虚拟机模式下的CPU会暂停虚拟机并</span><br><span class="line">        // 把执行权交给emulator</span><br><span class="line">        case KVM_EXIT_IO:</span><br><span class="line">            printf(&quot;KVM_EXIT_IO\n&quot;);</span><br><span class="line">            printf(&quot;out port: %d, data: %d\n&quot;, </span><br><span class="line">                kvm-&gt;vcpus-&gt;kvm_run-&gt;io.port,  </span><br><span class="line">                *(int *)((char *)(kvm-&gt;vcpus-&gt;kvm_run) + kvm-&gt;vcpus-&gt;kvm_run-&gt;io.data_offset)</span><br><span class="line">                );</span><br><span class="line">            sleep(1);</span><br><span class="line">            break;</span><br><span class="line">        // 虚拟机执行了memory map IO操作</span><br><span class="line">        case KVM_EXIT_MMIO:</span><br><span class="line">            printf(&quot;KVM_EXIT_MMIO\n&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case KVM_EXIT_INTR:</span><br><span class="line">            printf(&quot;KVM_EXIT_INTR\n&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case KVM_EXIT_SHUTDOWN:</span><br><span class="line">            printf(&quot;KVM_EXIT_SHUTDOWN\n&quot;);</span><br><span class="line">            goto exit_kvm;</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            printf(&quot;KVM PANIC\n&quot;);</span><br><span class="line">            goto exit_kvm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">exit_kvm:</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void kvm_reset_vcpu (struct vcpu *vcpu) &#123;</span><br><span class="line">    if (ioctl(vcpu-&gt;vcpu_fd, KVM_GET_SREGS, &amp;(vcpu-&gt;sregs)) &lt; 0) &#123;</span><br><span class="line">        perror(&quot;can not get sregs\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    // #define CODE_START 0x1000</span><br><span class="line">    /* sregs 结构体</span><br><span class="line">        x86</span><br><span class="line">        struct kvm_sregs &#123;</span><br><span class="line">            struct kvm_segment cs, ds, es, fs, gs, ss;</span><br><span class="line">            struct kvm_segment tr, ldt;</span><br><span class="line">            struct kvm_dtable gdt, idt;</span><br><span class="line">            __u64 cr0, cr2, cr3, cr4, cr8;</span><br><span class="line">            __u64 efer;</span><br><span class="line">            __u64 apic_base;</span><br><span class="line">            __u64 interrupt_bitmap[(KVM_NR_INTERRUPTS + 63) / 64];</span><br><span class="line">        &#125;;</span><br><span class="line">    */</span><br><span class="line">    // cs 为code start寄存器，存放了程序的起始地址</span><br><span class="line">    vcpu-&gt;sregs.cs.selector = CODE_START;</span><br><span class="line">    vcpu-&gt;sregs.cs.base = CODE_START * 16;</span><br><span class="line">    // ss 为堆栈寄存器，存放了堆栈的起始位置</span><br><span class="line">    vcpu-&gt;sregs.ss.selector = CODE_START;</span><br><span class="line">    vcpu-&gt;sregs.ss.base = CODE_START * 16;</span><br><span class="line">    // ds 为数据段寄存器，存放了数据开始地址</span><br><span class="line">    vcpu-&gt;sregs.ds.selector = CODE_START;</span><br><span class="line">    vcpu-&gt;sregs.ds.base = CODE_START *16;</span><br><span class="line">    // es 为附加段寄存器</span><br><span class="line">    vcpu-&gt;sregs.es.selector = CODE_START;</span><br><span class="line">    vcpu-&gt;sregs.es.base = CODE_START * 16;</span><br><span class="line">    // fs, gs 同样为段寄存器</span><br><span class="line">    vcpu-&gt;sregs.fs.selector = CODE_START;</span><br><span class="line">    vcpu-&gt;sregs.fs.base = CODE_START * 16;</span><br><span class="line">    vcpu-&gt;sregs.gs.selector = CODE_START;</span><br><span class="line"></span><br><span class="line">    // 为vCPU设置以上寄存器的值</span><br><span class="line">    if (ioctl(vcpu-&gt;vcpu_fd, KVM_SET_SREGS, &amp;vcpu-&gt;sregs) &lt; 0) &#123;</span><br><span class="line">        perror(&quot;can not set sregs&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 设置寄存器标志位</span><br><span class="line">    vcpu-&gt;regs.rflags = 0x0000000000000002ULL;</span><br><span class="line">    // rip 表示了程序的起始指针，地址为 0x0000000</span><br><span class="line">    // 在加载镜像的时候，我们直接将binary读取到了虚拟机的内存起始位</span><br><span class="line">    // 所以虚拟机开始的时候会直接运行binary</span><br><span class="line">    vcpu-&gt;regs.rip = 0;</span><br><span class="line">    // rsp 为堆栈顶</span><br><span class="line">    vcpu-&gt;regs.rsp = 0xffffffff;</span><br><span class="line">    // rbp 为堆栈底部</span><br><span class="line">    vcpu-&gt;regs.rbp= 0;</span><br><span class="line"></span><br><span class="line">    if (ioctl(vcpu-&gt;vcpu_fd, KVM_SET_REGS, &amp;(vcpu-&gt;regs)) &lt; 0) &#123;</span><br><span class="line">        perror(&quot;KVM SET REGS\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行一下结果，可以看到当虚拟机执行了指令 <code>out %ax, $0x10</code> 的时候，会引起虚拟机的退出，这是CPU虚拟化里面将要介绍的特殊机制。<br>宿主机获取到虚拟机退出的原因后，获取相应的输出。这里的步骤就类似于IO虚拟化，直接读取IO模块的内存，并输出结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">➜  kvmsample git:(master) ✗ ./kvmsample</span><br><span class="line">read size: 712288</span><br><span class="line">KVM start run</span><br><span class="line">KVM_EXIT_IO</span><br><span class="line">out port: 16, data: 0</span><br><span class="line">KVM start run</span><br><span class="line">KVM_EXIT_IO</span><br><span class="line">out port: 16, data: 1</span><br><span class="line">KVM start run</span><br><span class="line">KVM_EXIT_IO</span><br><span class="line">out port: 16, data: 2</span><br><span class="line">KVM start run</span><br><span class="line">KVM_EXIT_IO</span><br><span class="line">out port: 16, data: 3</span><br><span class="line">KVM start run</span><br><span class="line">KVM_EXIT_IO</span><br><span class="line">out port: 16, data: 4</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虚拟机的启动过程基本上可以这么总结：<br>创建kvm句柄-&gt;创建vm-&gt;分配内存-&gt;加载镜像到内存-&gt;启动线程执行KVM_RUN。从这个虚拟机的demo可以看出，虚拟机的内存是由宿主机通过mmap调用映射给虚拟机的，而vCPU是宿主机的一个线程，这个线程通过设置相应的vCPU的寄存器指定了虚拟机的程序加载地址后，开始运行虚拟机的指令，当虚拟机执行了IO操作后，CPU捕获到中断并把执行权又交回给宿主机。</p>
<p>当然真实的qemu-kvm比这个复杂的多，包括设置很多IO设备的MMIO，设置信号处理等。</p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p>本文中提到的所有源代码都可以从这里下载到，仅供大家学习交流使用<br><a href="https://github.com/ysun/kvm-cheat" target="_blank" rel="noopener">github|kvm-cheat</a></p>

    </div>

    
    
    
        <div class="reward-container">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    Donate
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="Yi颗烂樱桃 WeChat Pay">
        <p>WeChat Pay</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="Yi颗烂樱桃 Alipay">
        <p>Alipay</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/KVM/" rel="tag"># KVM</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2018/12/10/kvm-overview/" rel="prev" title="KVM 虚拟化原理1 -- 概述">
      <i class="fa fa-chevron-left"></i> KVM 虚拟化原理1 -- 概述
    </a></div>
      <div class="post-nav-item">
    <a href="/2018/12/10/kvm-cpu/" rel="next" title="KVM 虚拟化原理3--CPU">
      KVM 虚拟化原理3--CPU <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#虚拟机启动过程"><span class="nav-number">1.</span> <span class="nav-text">虚拟机启动过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#先来一个KVM-API开胃菜"><span class="nav-number">2.</span> <span class="nav-text">先来一个KVM API开胃菜</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#另外一个简单的QEMU-emulator-demo"><span class="nav-number">3.</span> <span class="nav-text">另外一个简单的QEMU emulator demo</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">4.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#源代码"><span class="nav-number">5.</span> <span class="nav-text">源代码</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yi颗烂樱桃" src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Yi颗烂樱桃</p>
  <div class="site-description" itemprop="description">这是一颗烂樱桃的技术博客，一个微不足道的魔都程序员，或者是自以为的程序员</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">46</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2018 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-snowflake-o"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yi颗烂樱桃</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>

  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>


  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  <script src="/js/local-search.js"></script>












  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '30a5af43b5ea724ad81b',
      clientSecret: '3426c0800920f9f75967ecf4b87f453e8012b911',
      repo        : 'ysun.github.io',
      owner       : 'ysun',
      admin       : ['ysun'],
      id          : 'cfa3772f93faa412e64d588e228d7163',
        language: '',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
